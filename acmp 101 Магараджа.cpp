//Author - Artak Sanamyan
#include <bits/stdc++.h>  //подключает все модули с++. Работает только под gcc
using namespace std;
  
int n, k, yi[11], cnt = 0, Q = 0; 
//yi - y координата i-ого ферзя
//cnt - кол-во способов расставить k "мирных" Ферзей на доске n*n, т.е. наш ответ 
//Q - кол-во поставленных Ферзей на данный момент
  
bool ok(int x, int y)  
//проверка бьёт ли хотя бы один из уже поставленных ферзей клетку, на которую мы хотим поставить нового ферзя
//x, y - координаты клетки, на которую мы хотим поставить нового ферзя   
{
    int x1; //x1 - номер столбца, yi[x1] - номер строки одного из уже поставленных ферзей
    //если yi[x1] == 0, значит, в этом x1-ом столбце ферзя нет
    //проверки:  2 ферзя на одной строке, диагонали                               ход коня или если нет ферзя в x1-ом столбце  
    for (x1 = 1; x1 < x && (yi[x1] != y && abs(x1 - x) != abs(yi[x1] - y) && abs(x1 - x) * abs(yi[x1] - y) > 2 || yi[x1] == 0); x1++);
    //в итоге x1 будет равен номеру столбца ферзя, который бьет нового ферзя
    //либо x1 будет равен x, значит, можем ставить нового фрезя на клетку (x, y)
    return x1 == x; 
}
  
void rec(int x)
//рекурсивная процедура, осуществляющая перебор с откатом(backtracking)
//x - глубина рекурсии, а также номер столбца, на который мы хотим поставить нового ферзя
{
    if (Q == k)
    //условие выхода из рекурсии
    {
        cnt++; //нашли новый способ - увеличиваем счётчик
         
        //вывод расстановки
        /*cout << endl << "variant #" << cnt;
        for (int i = n; i; i--)
        {
            cout << endl << i << " "; //i - номер строки
            for (int j = 1; j <= n; j++) 
                if (yi[j] == i)
                    cout << "Q"; //Q - ферзь
                else 
                    cout << "x"; //x - пустая клетка
        }
          
        cout << endl << "  ";
        for (int j = 1; j <= n; j++) 
            cout << j; //j - номер столбца
       
        cout << endl;*/
       
        return; //выход
    }
  
    //ещё одно условие выхода из рекурсии
    //если перебрали все столбцы - выход
    if (x == n + 1)
        return;
  
    //перебираем y координату, если y == 0, то этот столбец оставляем пустым 
    for (int y = 0; y <= n; y++)
        if (!y || ok(x, y))
        {
            if (y) Q++;
            yi[x] = y;
            rec(x + 1);
            //(ниже) откатываем всё на шаг назад
            yi[x] = 0;
            if (y) Q--;
        }
}
  
int main()
{
    cin >> n >> k;
    rec(1);
    cout << cnt;
    return 0;
}